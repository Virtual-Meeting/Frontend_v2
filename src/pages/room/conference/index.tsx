import React, { useEffect, useRef, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import * as kurentoUtils from 'kurento-utils';
import fixWebmDuration from 'webm-duration-fix';
import Header from 'components/common/Header';
import Participant from 'lib/webrtc/Participant';
import ParticipantVideo from 'components/common/Video/ParticipantVideo';
import CallControls from 'components/common/CallControls';
import { Wrapper, GalleryWrapper, MainArea, ParticipantVideoGroup } from './Conference.styles';
import Sidebar from 'components/common/Sidebar';
import { ChatMessage, ChatMessageInput } from 'types/chat';
import { EmojiMessage } from 'types/emoji';
import EmojiPicker from 'components/common/EmojiPicker';
import ChangeNameForm from 'components/common/UserSettings/ChangeNameForm';
import RecordingStatusPopup from 'components/common/Recording/RecordingStatusPopup';
import ListPopup from 'components/common/ListPopup';
import RecordingPermissionPopup from 'components/common/Recording/RecordingPermissionPopup';
import RecordingConsentPopup from 'components/common/Recording/RecordingConsentPopup';
// import { useScreenRecording } from 'lib/hooks/useRecording';
import { useRecording } from 'lib/hooks/useRecording';
import { useTopSpeaker } from 'lib/hooks/useTopSpeaker';
import { useSortedSpeakers } from 'lib/hooks/useSortedSpeakers';
import NameChangePopup from 'components/common/NameChangePopup';
import AudioInputSelector from 'components/common/UserSettings/AudioInputSelector';
import VideoInputSelector from 'components/common/UserSettings/VideoInputSelector';

type ConferenceProps = {
    name: string;
    roomId: string;
    isVideoOn: boolean;
    isAudioOn: boolean;
    videoDeviceId?: string;
    audioDeviceId?: string;
};

// User data ÌÉÄÏûÖ Ï†ïÏùò
interface UserData {
    sessionId: string;
    username: string;
    roomId: string;
    audioOn: boolean;
    videoOn: boolean;
}

// const wsServerUrl = "wss://vmo.o-r.kr:8080";
const wsServerUrl = "ws://localhost:8080";

const iceServers = [
    { urls: "stuns:stun.l.google.com:19302" },
    { urls: "stun:stun1.l.google.com:19302" },
    { urls: "stun:stun2.l.google.com:19302" },
    {
        urls: "turn:vmo.o-r.kr:3478",
        username: "user",
        credential: "1234abcd"
    },
    {
        urls: "turns:vmo.o-r.kr:5349",
        username: "user",
        credential: "1234abcd"
    }
];

const Conference: React.FC<ConferenceProps> = ({ 
        name,
        roomId,
        isVideoOn,
        isAudioOn,
        videoDeviceId,
        audioDeviceId 
    }) => {

    //CallControlsÏóêÏÑú Î∞õÎäî Í∞í
    const [micOn, setMicOn] = useState(isAudioOn);
    const [videoOn, setVideoOn] = useState(isVideoOn);

    const micOnRef = useRef(micOn);

    const [participantsVisible, setParticipantsVisible] = useState(false);
    const [chatVisible, setChatVisible] = useState(false);
    const [screenSharing, setScreenSharing] = useState(false);
    const [recording, setRecording] = useState(false);
    const [recordingPaused, setRecordingPaused] = useState(true);
    const [recordingListVisible, setRecordingListVisible] = useState(false);
    const [recordingPopupVisible, setRecordingPopupVisible] = useState(false);
    const [recordingConsentPopupVisible, setRecordingConsentPopupVisible] = useState(false);

    const [captionsVisible, setCaptionsVisible] = useState(false);
    const [emotesVisible, setEmotesVisible] = useState(false);
    const [handRaised, setHandRaised] = useState(false);
    const [changeNamePopupVisible, setChangeNamePopupVisible] = useState(false);

    const [micListVisible, setMicListVisible] = useState(false);
    const [videoListVisible, setVideoListVisible] = useState(false);

    //Ï∞∏Í∞ÄÏûê Ï†êÏàò Ï†ÄÏû•
    const [speakingScores, setSpeakingScores] = useState<{ [id: string]: number }>({});
    const [firstSpokenTimestamps, setFirstSpokenTimestamps] = useState<{ [id: string]: number }>({});

    const handleMicListToggle = () => setMicListVisible(prev => !prev);
  const handleVideoListToggle = () => setVideoListVisible(prev => !prev);
  
    const handleSpeakingScoreChange = (sessionId: string, score: number) => {
        setSpeakingScores(prev => {
            if (prev[sessionId] === score) {
                return prev;
            }
            return { ...prev, [sessionId]: score };
        });

        setFirstSpokenTimestamps(prev => {
            if (prev[sessionId] != null || score <= 0) return prev;
            return { ...prev, [sessionId]: Date.now() };
        });
    };
    const topSpeaker = useTopSpeaker(speakingScores);
    const topSpeakerRef = useRef(topSpeaker);
    const sortedSpeakerIds = useSortedSpeakers(speakingScores, firstSpokenTimestamps);

    const mainSpeakerId = sortedSpeakerIds[0];
    const subSpeakerIds = sortedSpeakerIds.slice(1);


    const handleMicToggle = () => {
        const newMicState = !micOn;
        setMicOn(newMicState);

        sendMessage({
            eventId: 'audioStateChange',
            audioOn: newMicState
        });
    };

    const handleVideoToggle = () => {
        const newVideoState = !videoOn;
        setVideoOn(newVideoState);

        sendMessage({
            eventId: 'videoStateChange',
            videoOn: newVideoState
        });
    };

    // const handleScreenSharingToggle = () => setScreenSharing((prev) => !prev);
    const [videoTracks, setVideoTracks] = useState<{
    [id: string]: { video: MediaStreamTrack; audio: MediaStreamTrack };
    }>({});

    const handleScreenSharingToggle = async () => {
        const participant = participantsRef.current[userData.sessionId];
        if (!participant?.rtcPeer) return;

        const peerConnection = participant.rtcPeer.peerConnection;
        const videoSender = peerConnection.getSenders().find(s => s.track?.kind === "video");
        const audioSender = peerConnection.getSenders().find(s => s.track?.kind === "audio");

        if (!videoSender || !audioSender) return;

        if (!screenSharing) {
        try {
            const displayStream = await navigator.mediaDevices.getDisplayMedia({
            video: true,
            audio: true,
            });

            const micStream = await navigator.mediaDevices.getUserMedia({
            audio: true,
            });

            const screenTrack = displayStream.getVideoTracks()[0];
            const micTrack = micStream.getAudioTracks()[0];

            // Í∏∞Ï°¥ Ìä∏ÎûôÏùÑ Î®ºÏ†Ä Ï†ÄÏû•
            const prevVideoTrack = videoSender.track;
            const prevAudioTrack = audioSender.track;

            setVideoTracks(prev => ({
            ...prev,
            [userData.sessionId]: {
                video: prevVideoTrack,
                audio: prevAudioTrack,
            }
            }));

            // Ìä∏Îûô ÍµêÏ≤¥
            await videoSender.replaceTrack(screenTrack);
            await audioSender.replaceTrack(micTrack);

            // ÎπÑÎîîÏò§ ÏóòÎ¶¨Î®ºÌä∏Ïóê ÌôîÎ©¥Í≥µÏú† Ïä§Ìä∏Î¶º Ìï†Îãπ
            const localVideoEl = videoRefs.current[userData.sessionId]?.current;
            if (localVideoEl) localVideoEl.srcObject = displayStream;

            setScreenSharing(true);

            screenTrack.onended = async () => {
            const prevTracks = videoTracks[userData.sessionId];
            if (prevTracks?.video) await videoSender.replaceTrack(prevTracks.video);
            if (prevTracks?.audio) await audioSender.replaceTrack(prevTracks.audio);

            if (localVideoEl && localStreamRef.current) {
                localVideoEl.srcObject = localStreamRef.current;
            }

            setScreenSharing(false);
            };

            } catch (err) {
            console.error("ÌôîÎ©¥ Í≥µÏú† ÏãúÏûë Ïò§Î•ò:", err);
            }
        } else {
            // üîÅ ÏõêÎûò Ìä∏Îûô Î≥µÍµ¨
            const prevTracks = videoTracks[userData.sessionId];
            if (prevTracks?.video) await videoSender.replaceTrack(prevTracks.video);
            if (prevTracks?.audio) await audioSender.replaceTrack(prevTracks.audio);

            const localVideoEl = videoRefs.current[userData.sessionId]?.current;
            if (localVideoEl && localStreamRef.current) {
            localVideoEl.srcObject = localStreamRef.current;
            }

            setScreenSharing(false);
        }
    };

    const replaceAudioTrack = async (newDeviceId: string) => {
  const participant = participantsRef.current[userData.sessionId];
  if (!participant?.rtcPeer) return;

  const audioSender = participant.rtcPeer.peerConnection
    .getSenders()
    .find((s) => s.track?.kind === "audio");

  if (!audioSender) return;

  const newStream = await navigator.mediaDevices.getUserMedia({
    audio: { deviceId: { exact: newDeviceId } }
  });

  const newAudioTrack = newStream.getAudioTracks()[0];
  await audioSender.replaceTrack(newAudioTrack);

  // Î°úÏª¨ ÎπÑÎîîÏò§ Ïä§Ìä∏Î¶ºÏóêÎèÑ Î∞òÏòÅ
  const localStream = localStreamRef.current;
  if (localStream) {
    localStream.removeTrack(localStream.getAudioTracks()[0]);
    localStream.addTrack(newAudioTrack);
  }

  // UIÏóêÏÑúÎèÑ Îì£Í∏∞ Î∞òÏòÅ
  const localVideoEl = videoRefs.current[userData.sessionId]?.current;
  if (localVideoEl) {
    localVideoEl.srcObject = localStream;
  }
};
const replaceVideoTrack = async (newDeviceId: string) => {
  const participant = participantsRef.current[userData.sessionId];
  if (!participant?.rtcPeer) return;

  const videoSender = participant.rtcPeer.peerConnection
    .getSenders()
    .find((s) => s.track?.kind === "video");

  if (!videoSender) return;

  const newStream = await navigator.mediaDevices.getUserMedia({
    video: { deviceId: { exact: newDeviceId } }
  });

  const newVideoTrack = newStream.getVideoTracks()[0];
  await videoSender.replaceTrack(newVideoTrack);

  const localStream = localStreamRef.current;
  if (localStream) {
    localStream.removeTrack(localStream.getVideoTracks()[0]);
    localStream.addTrack(newVideoTrack);
  }

  const localVideoEl = videoRefs.current[userData.sessionId]?.current;
  if (localVideoEl) {
    localVideoEl.srcObject = localStream;
  }
};


    const handleRecordingToggle = () => {
        if(roomLeader.sessionId===userData.sessionId){   
            startRecording();
        }else{
            sendMessage({eventId:'requestRecordingPermission'});  
        }

        stopRecording();
    };

    const startRecording = () => {
        if(!recording){
            sendMessage({ eventId: 'startRecording' });
            setRecording((prev) => !prev);
        }
    };

    const stopRecording = () => {
        if(recording) {
            sendMessage({ eventId: 'stopRecording' });
        }
    }

    const handleCaptionsToggle = () => setCaptionsVisible((prev) => !prev);
    const handleChatToggle = () => setChatVisible((prev) => !prev);
    const handleParticipantsToggle = () => setParticipantsVisible((prev) => !prev);
    const handleEmotesToggle = () => setEmotesVisible((prev) => !prev);

    const navigate = useNavigate();

    // ÎÖπÌôî Î¶¨Ïä§Ìä∏ ÌåùÏóÖ Ïó¥Í∏∞/Îã´Í∏∞
    const handleRecordingListToggle = () => {
        setRecordingListVisible(prev => !prev);
    };

    // ÎÖπÌôî Î¶¨Ïä§Ìä∏ ÌåùÏóÖ Îã´Í∏∞
    const closeRecordingList = () => {
        setRecordingListVisible(false);
    };

    const isJoin = roomId.trim().length > 0;
    const ws = useRef<WebSocket | null>(null);
    const localStreamRef = useRef<MediaStream | null>(null);
    const videoRefs = useRef<{ [sessionId: string]: React.RefObject<HTMLVideoElement> }>({});
    

    const [participants, setParticipants] = useState<{ [sessionId: string]: Participant }>({});
    const participantsRef = useRef<{ [sessionId: string]: Participant }>({});
    const [roomLeader, setRoomLeader] = useState<{ sessionId: string; username: string }>({ sessionId: '', username: ''});
    const [recordedFiles, setRecordedFiles] = useState<RecordedFile[]>([]);
    const [elapsed, setElapsed] = useState(0); //ÎÖπÌôî ÏãúÍ∞Ñ Ï†ÄÏû•
    const [pendingSessionId, setPendingSessionId] = useState<string | null>(null);

    //ÌîÑÎ°†Ìä∏ ÎÖπÌôî Ìï®ÏàòÎì§
    const { start, stop, pause, resume, setMicEnabled } = useRecording({
        onStop: async (blob) => {
            const fixedBlob = await fixWebmDuration(blob);
            const url = URL.createObjectURL(fixedBlob);
            const fileName = getFileName();
            setRecordedFiles(prev => [...prev, { url, fileName, duration: elapsed }]);
            setElapsed(0);
        }
    });

    //ÎÖπÌôîÎ≥∏ Ïù¥Î¶Ñ
    const getFileName = () => {
        const now = new Date();
        return `recording_${now.toISOString().replace(/[:.]/g, '-')}.webm`;
    };


    const [userData, setUserData] = useState<UserData>({
        sessionId: '',
        username: name,
        roomId: roomId,
        audioOn: isAudioOn,
        videoOn: isVideoOn,
    });
    const userDataRef = useRef(userData);

    const [chatMessages, setChatMessages] = useState<ChatMessage[]>([]);
    const [emojiMessages, setEmojiMessages] = useState<EmojiMessage[]>([]);
    const [systemMessages, setSystemMessages] = useState<SystemMessage[]>([]);

    //ÏÜêÎì† ÏÇ¨Îûå Î™©Î°ù
    const [raisedHandSessionIds, setRaisedHandSessionIds] = useState<string[]>([]);

    const hasSidebar = chatVisible || participantsVisible;

    useEffect(()=>{
        ws.current = new WebSocket(wsServerUrl);

        ws.current.onopen = () => {
            console.log('WebSocket connection opened.');

            const message = isJoin ? {
                eventId: 'joinRoom',
                username: name,
                roomId: roomId,
                audioOn: isAudioOn,     // Ïò§ÎîîÏò§ ÏÉÅÌÉú Í∞í
                videoOn: isVideoOn,     // ÎπÑÎîîÏò§ ÏÉÅÌÉú Í∞í
            }:{
                eventId: 'createRoom',
                username: name,
                audioOn: isAudioOn,
                videoOn: isVideoOn,
            }

            ws.current.send(JSON.stringify(message));
        };

        // ‚úÖ Î∏åÎùºÏö∞Ï†Ä Îã´Í∏∞/ÏÉàÎ°úÍ≥†Ïπ® Ïãú exitRoom Ï†ÑÏÜ°
        const handleBeforeUnload = () => {
            if (ws.current && ws.current.readyState === WebSocket.OPEN) {
                const exitMessage = {
                    eventId: 'exitRoom',
                    username: name,
                    roomId: roomId,
                };
                ws.current.send(JSON.stringify(exitMessage));
            }
        };

        window.addEventListener('beforeunload', handleBeforeUnload);

        ws.current.onmessage = (message) => {
            let parsedMessage = JSON.parse(message.data);
            console.info('Received message: ' + message.data);

            // ÏóêÎü¨ Î©îÏãúÏßÄ Ï≤òÎ¶¨
            if (parsedMessage.type === "ERROR" && parsedMessage.message?.includes("Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Î∞©ÏûÖÎãàÎã§")) {
                alert(parsedMessage.message);
                navigate('/');  // useNavigate() ÌõÖÏúºÎ°ú Ïù¥ÎèôÌïòÏÑ∏Ïöî
                return; // Ïù¥ÌõÑ Ï≤òÎ¶¨ Ï§ëÎã®
            }

            switch (parsedMessage.action) {
                case 'roomCreated':
                    roomCreated(parsedMessage);
                    break;
                case 'sendExistingUsers':
                    sendExistingUsers(parsedMessage);
                    break;
                case 'newUserJoined':
                    newUserJoined(parsedMessage);
                    break;
                case 'onIceCandidate': //ÏÇ¨Ïö©Ïûê peerÏó∞Í≤∞
                    onIceCandidate(parsedMessage);
                    break;
                case 'receiveVideoAnswer': //ÎπÑÎîîÏò§ Ïó∞Í≤∞
                    receiveVideoResponse(parsedMessage);
                    break;
                case 'exitRoom':
                    userLeft(parsedMessage);
                    break;
                case 'leaderChanged':
                    handleLeaderChanged(parsedMessage);
                    break;
                case 'sendPersonalChat':
                    handleChatMessage(parsedMessage, true);
                    break;
                case 'broadcastChat':
                    handleChatMessage(parsedMessage, false);
                    break;
                case 'audioStateChange':
                    handleAudioStateChange(parsedMessage);
                    break;
                case 'videoStateChange':
                    handleVideoStateChange(parsedMessage);
                    break;
                // case 'sendPrivateEmoji': //ÎπÑÍ≥µÍ∞ú Ïù¥Î™®ÏßÄ
                //     handleEmojiMessage(parsedMessage, true);
                //     break;
                case 'sendPublicEmoji': //Í≥µÍ∞ú Ïù¥Î™®ÏßÄ
                    handleEmojiMessage(parsedMessage);
                    break;
                case 'cancelHandRaise': //ÏÜêÎì§Í∏∞ Ï≤†Ìöå
                    setRaisedHandSessionIds((prev) =>
                        prev.filter((id) => id !== parsedMessage.sessionId)
                    );
                    break;
                case 'changeName': //Ïù¥Î¶Ñ Î≥ÄÍ≤Ω
                    handleUsernameChanged(parsedMessage);
                    break;
                
                //ÎÖπÌôî Í∏∞Îä•
                case 'startRecording': // ÎÖπÌôî ÏãúÏûë
                    sendMessage({ eventId: 'confirmRecordingConsent' });
                    start(micOnRef.current).then(() => {
                        setRecordingPaused(false); // ÌÉÄÏù¥Î®∏ Ïù¥Ï†ú ÏãúÏûë Í∞ÄÎä•
                    }).catch((err) => {
                        console.error('ÎÖπÌôî ÏãúÏûë Ïã§Ìå®:', err);
                    });
                    break;
                case 'stopRecording': // ÎÖπÌôî Ï§ëÏßÄ
                    stop();
                    finalizeRecordingSession();
                    break;
                // case 'saveRecording': // ÎÖπÌôîÎ≥∏ Îã§Ïö¥Î°úÎìú
                //     break;
                case 'pauseRecording': // ÎÖπÌôî ÏùºÏãúÏ†ïÏßÄ
                    pause();
                    setRecordingPaused(true);
                    break;
                case 'resumeRecording': // ÎÖπÌôî Ïû¨Í∞ú
                    resume();
                    setRecordingPaused(false);
                    break;
                
                //ÎÖπÌôî Í∂åÌïú
                case 'requestRecordingPermission':
                    setPendingSessionId(parsedMessage.sessionId);
                    setRecordingPopupVisible(true);
                    break;
                case 'grantRecordingPermission':
                    startRecording();
                    break;
                case 'denyRecordingPermission':
                    break;
                
                //ÎÖπÌôî ÎèôÏùò
                case 'confirmRecordingConsent':
                    setRecordingConsentPopupVisible(true);
                    break;
                default:
                    console.error('Unrecognized message', parsedMessage);
            }
        }

        return () => {
            if(ws.current){
                console.log("Closing WebSocket connection.");
                ws.current.close();  // ÏõπÏÜåÏºì Ïó∞Í≤∞ Ï¢ÖÎ£å
            }
        }
    },[]);

    useEffect(()=>{
        console.log("userData:",userData);
    },[userData]);

    useEffect(() => {
        topSpeakerRef.current = topSpeaker;
    }, [topSpeaker]);

    const sendMessage = (message) => {
        let jsonMessage = JSON.stringify(message);
        console.log('Sending message: ' + jsonMessage);
        if (ws.current && ws.current.readyState === WebSocket.OPEN) {
            ws.current.send(jsonMessage);
        }
    }
    
    const roomCreated = (response:{ 
        sessionId: string;
        username: string;
        roomId: string;
        roomLeaderId: string;
        roomLeaderName: string;
     }) => {
        console.log('Room created response:', response);

        // ÏÑúÎ≤ÑÏóêÏÑú Î∞õÏùÄ ÏùëÎãµÏóê ÎßûÍ≤å Ïú†Ï†Ä Îç∞Ïù¥ÌÑ∞Î•º ÏóÖÎç∞Ïù¥Ìä∏
        setUserData((prevData) => ({
            ...prevData,
            sessionId: response.sessionId,
            roomId: response.roomId, // Î∞© ID ÏóÖÎç∞Ïù¥Ìä∏
        }));

        sendExistingUsers(response);
    }

    const receiveVideo = (sender) => {
        let participant = participantsRef.current[sender.sessionId];

        if (!participant) {
            participant = new Participant(sender.sessionId, sender.username, sendMessage, sender.videoOn, sender.audioOn);

            // ÎπÑÎîîÏò§ ref Îì±Î°ù
            if (!videoRefs.current[sender.sessionId]) {
                videoRefs.current[sender.sessionId] = React.createRef<HTMLVideoElement>();
            }
            console.log("videoRefs.current[sender.sessionId]",videoRefs.current[sender.sessionId]);

            participantsRef.current[sender.sessionId] = participant;
            setParticipants(prev => ({
                ...prev,
                [sender.sessionId]: participant
            }));

            setSpeakingScores(prev => ({
                ...prev,
                [sender.sessionId]: 0
            }));
        }

        // üí° Î†åÎçîÎßÅ Ïù¥ÌõÑÍπåÏßÄ Í∏∞Îã§Î†∏Îã§Í∞Ä ÎπÑÎîîÏò§ Ïó∞Í≤∞ ÏãúÎèÑ
        setTimeout(() => {
            const videoElement = videoRefs.current[sender.sessionId]?.current;

            if (!videoElement) {
                console.warn("‚ùó ÎπÑÎîîÏò§ ÏöîÏÜåÍ∞Ä ÏïÑÏßÅ Ï§ÄÎπÑÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§:", sender.sessionId);
                return;
            }

            const options = {
                configuration: { iceServers },
                remoteVideo: videoElement,
                onicecandidate: participant.onIceCandidate.bind(participant),
            };

            participant.rtcPeer = new kurentoUtils.WebRtcPeer.WebRtcPeerRecvonly(options, function (error) {
                if (error) {
                    console.error("WebRtcPeerRecvonly ÏÉùÏÑ± Ïã§Ìå®:", error);
                    return;
                }

                this.generateOffer(participant.offerToReceiveVideo.bind(participant));
                participant.rtcPeer.peerConnection.addEventListener("track", (event) => {
                console.log(`[Participant ${participant.sessionId}] Ìä∏Îûô Ï∂îÍ∞ÄÎê®: ${event.track.kind}`);

                const remoteStream = event.streams[0]; // Ìä∏ÎûôÏù¥ Ìè¨Ìï®Îêú MediaStream

                const videoEl = videoRefs.current[participant.sessionId]?.current;
                if (videoEl && !videoEl.srcObject) {
                    videoEl.srcObject = remoteStream;
                    console.log(`[Participant ${participant.sessionId}] video.srcObjectÏóê remoteStream Ìï†ÎãπÎê®`);
                }
                });
            });
        }, 1000); // üí° 100ms Ï†ïÎèÑÏùò ÏßßÏùÄ ÏßÄÏó∞
    };


    const newUserJoined = (msg) => {
        receiveVideo(msg);
    }

    const sendExistingUsers = (msg) => {
        const participant = new Participant(msg.sessionId, msg.username,sendMessage, msg.videoOn, msg.audioOn);
        participantsRef.current[msg.sessionId] = participant;

        setRoomLeader({
            sessionId: msg.roomLeaderId,
            username: msg.roomLeaderName,
        });

        setParticipants(prev => ({
            ...prev,
            [msg.sessionId]: participant
        }));

        setSpeakingScores(prev => ({
            ...prev,
            [msg.sessionId]: 0
        }));

        setUserData((prevData) => ({
            ...prevData,
            sessionId: msg.sessionId,
        }));

        if (msg.roomId) {
            addSystemMessage(`üì¢ ÌòÑÏû¨ Î∞© ÏΩîÎìú: ${msg.roomId}`);
        } else if (userData.roomId) {
            addSystemMessage(`üì¢ ÌòÑÏû¨ Î∞© ÏΩîÎìú: ${userData.roomId}`);
        }
        

        if (!videoRefs.current[msg.sessionId]) {
            videoRefs.current[msg.sessionId] = React.createRef<HTMLVideoElement>();
        }
        
        console.log("videoRefs.current[msg.sessionId]",videoRefs.current[msg.sessionId]);
        const localVideoRef = videoRefs.current[msg.sessionId];

        // getUserMedia ‚Üí WebRTC Ïó∞Í≤∞
        navigator.mediaDevices.getUserMedia({ audio: true, video: true })
            .then((stream) => {
                 // Ïä§Ìä∏Î¶º Ï†ÑÏó≠Ïóê Ï†ÄÏû•
                localStreamRef.current = stream;

                // ÌòÑÏû¨ Ïò§ÎîîÏò§/ÎπÑÎîîÏò§ ÏÉÅÌÉú Î∞òÏòÅ
                stream.getAudioTracks().forEach(track => (track.enabled = micOn));
                stream.getVideoTracks().forEach(track => (track.enabled = videoOn));

                // ÎπÑÎîîÏò§ ÏóòÎ¶¨Î®ºÌä∏Í∞Ä Î†åÎçîÎßÅÎêòÍ≥† refÍ∞Ä Ïó∞Í≤∞Îê† ÎïåÍπåÏßÄ Ïû†Ïãú ÎîúÎ†àÏù¥
                setTimeout(() => {
                    const localVideoEl = videoRefs.current[msg.sessionId]?.current;
                    if (localVideoEl) {
                        localVideoEl.srcObject = stream;
                        console.log(`[Participant ${msg.sessionId}] video.srcObject set.`);
                    } else {
                        console.warn(`[Participant ${msg.sessionId}] video element not ready yet.`);
                    }
                }, 100); // 100ms ÎîúÎ†àÏù¥ (ÌïÑÏöîÏóê Îî∞Îùº Ï°∞Ï†à)

                // if (localVideoRef.current) {
                //     localVideoRef.current.srcObject = stream;
                // }

                const options = {
                    configuration: {iceServers: iceServers},
                    localVideo: stream,
                    mediaConstraints: { audio: true, video: true },
                    onicecandidate: participant.onIceCandidate.bind(participant),
                };

                participant.rtcPeer = new kurentoUtils.WebRtcPeer.WebRtcPeerSendonly(options, function (error: any) {
                    if (error) {
                        return console.error("WebRtcPeerSendonly ÏÉùÏÑ± Ïò§Î•ò:", error);
                    }

                    this.peerConnection.addEventListener("iceconnectionstatechange", () => {
                        console.log(`ICE ÏÉÅÌÉú: ${this.peerConnection.iceConnectionState}`);
                    });

                    this.generateOffer(participant.offerToReceiveVideo.bind(participant));
                });
                // Í∏∞Ï°¥ Ï∞∏Í∞ÄÏûê Î™©Î°ù Ï≤òÎ¶¨
                if (msg.participants && Array.isArray(msg.participants)) {
                    msg.participants.forEach((existingParticipantInfo) => {
                        // Í∏∞Ï°¥ Ï∞∏Í∞ÄÏûê Ï≤òÎ¶¨
                        const existingParticipant = parseParticipant(existingParticipantInfo);

                        // Í∏∞Ï°¥ Ï∞∏Í∞ÄÏûêÏóêÍ≤å ÎπÑÎîîÏò§ ÏàòÏã† ÏÑ§Ï†ï
                        receiveVideo(existingParticipant);
                    });
                }
            })
            .catch((error) => {
                console.error("Î°úÏª¨ ÎØ∏ÎîîÏñ¥ Ï†ëÍ∑º Ïò§Î•ò:", error);
            });        
    }

    const parseParticipant = (participantInfo) => {
        // Î¨∏ÏûêÏó¥Ïù¥Î©¥ JSON ÌååÏã±
        if (typeof participantInfo === 'string') {
            try {
            const parsed = JSON.parse(participantInfo);
            const result = {
                sessionId: parsed.sessionId,
                username: parsed.username,
                audioOn: typeof parsed.audioOn === "string" ? parsed.audioOn === "true" : !!parsed.audioOn,
                videoOn: typeof parsed.videoOn === "string" ? parsed.videoOn === "true" : !!parsed.videoOn,
            };
            console.log("‚úÖ ÌååÏã±Îêú Ï∞∏Í∞ÄÏûê:", result);
            return result;
            } catch (e) {
            console.error("‚ùå Î¨∏ÏûêÏó¥ ÌååÏã± Ïã§Ìå®:", participantInfo, e);
            return null;
            }
        }

        // Í∞ùÏ≤¥Î©¥ Í∑∏ÎåÄÎ°ú Ï≤òÎ¶¨
        return {
            sessionId: participantInfo.sessionId,
            username: participantInfo.username,
            audioOn: typeof participantInfo.audioOn === 'string' ? participantInfo.audioOn === "true" : !!participantInfo.audioOn,
            videoOn: typeof participantInfo.videoOn === 'string' ? participantInfo.videoOn === "true" : !!participantInfo.videoOn
        };
    };

    const receiveVideoResponse = (result: { sessionId: string; sdpAnswer: string }) => {
        // Ï∞∏Í∞ÄÏûêÍ∞Ä Ï°¥Ïû¨ÌïòÎäîÏßÄ ÌôïÏù∏
        let participant = participantsRef.current[result.sessionId]

        if (!participant) {
            console.error(`Participant with sessionId ${result.sessionId} not found.`);
            return;
        }

        // rtcPeerÍ∞Ä ÏóÜÏúºÎ©¥ ÏÉàÎ°úÏö¥ rtcPeerÎ•º ÏÉùÏÑ±Ìï¥Ïïº Ìï®
        if (!participant.rtcPeer) {
            console.error(`rtcPeer for participant ${result.sessionId} is not initialized.`);
            return;
        }

        // processAnswer Ìò∏Ï∂ú
        participant.rtcPeer.processAnswer(result.sdpAnswer, function (error: any) {
            if (error) {
                console.error('Error processing SDP answer:', error);
                return;
            }
            console.log('SDP answer processed successfully');
        });
    };


    const onIceCandidate = (message: any) => {
        const { sessionId, candidate } = message;
        const participant = participantsRef.current[sessionId];

        // 1. Ï∞∏Í∞ÄÏûêÍ∞Ä Ï°¥Ïû¨ÌïòÎäîÏßÄ ÌôïÏù∏
        if (!participant) {
            console.error(`Participant with sessionId ${sessionId} does not exist.`);
            return;
        }

        // 2. rtcPeerÍ∞Ä ÏÉùÏÑ±ÎêòÏßÄ ÏïäÏïòÎã§Î©¥, Ï¥àÍ∏∞ÌôîÍ∞Ä ÌïÑÏöî
        if (!participant.rtcPeer) {
            console.error(`rtcPeer is not initialized for participant ${sessionId}`);
            return;
        }

        // 3. ICE ÌõÑÎ≥¥Î•º rtcPeerÏóê Ï∂îÍ∞Ä
        const iceCandidate = new RTCIceCandidate(candidate);
        participant.rtcPeer.addIceCandidate(iceCandidate, (error) => {
            if (error) {
                console.error('Failed to add ICE candidate:', error);
            } else {
                console.log('ICE candidate added for participant:', sessionId);
            }
        });
    };

    const exitRoom = () => {
        const message = {
            eventId: 'exitRoom',
            sessionId: userData.sessionId
        };
        
        sendMessage(message);
        navigate('/');
    }

    const userLeft = (request: { sessionId: string }) => {
        const sessionId = request.sessionId;
        const participant = participantsRef.current[sessionId];

        if (!participant) {
            console.warn("üö´ Ìï¥Îãπ sessionIdÏùò Ï∞∏Í∞ÄÏûêÍ∞Ä ÏóÜÏäµÎãàÎã§:", sessionId);
            return;
        }

        console.log("üëã ÏÇ¨Ïö©Ïûê Ìá¥Ïû• Ï≤òÎ¶¨ ÏãúÏûë:", participant.username);

        // 1. WebRTC Ïó∞Í≤∞ Ï†ïÎ¶¨
        participant.dispose();

        // 2. ref Í∞ùÏ≤¥ÏóêÏÑú ÏÇ≠Ï†ú
        delete participantsRef.current[sessionId];
        delete videoRefs.current[sessionId];

        // 3. ÏÉÅÌÉúÏóêÏÑú Ï†úÍ±∞ ‚Üí UIÏóêÏÑú ÏÇ¨ÎùºÏßê
        setParticipants(prev => {
            const updated = { ...prev };
            delete updated[sessionId];
            return updated;
        });

        setSpeakingScores(prev => {
            const updated = { ...prev };
            delete updated[sessionId];
            return updated;
        });

        setFirstSpokenTimestamps(prev => {
            const updated = { ...prev };
            delete updated[sessionId];
            return updated;
        });
        // 4. Î∞©Ïû•Ïù¥ ÎÇòÍ∞îÎã§Î©¥ ÏΩòÏÜî ÏïåÎ¶º (Î∞©Ïû• Î≥ÄÍ≤ΩÏùÄ ÏÑúÎ≤ÑÏóêÏÑú Î≥ÑÎèÑ Ïù¥Î≤§Ìä∏Î°ú Ï≤òÎ¶¨ Ï§ë)
        if (roomLeader.sessionId === sessionId) {
            console.log("‚ö†Ô∏è Î∞©Ïû•Ïù¥ Ìá¥Ïû•ÌñàÏäµÎãàÎã§. ÏÑúÎ≤ÑÏóêÏÑú leaderChanged Ïù¥Î≤§Ìä∏Í∞Ä Ïò§Í∏∞Î•º ÎåÄÍ∏∞ Ï§ë...");
        }
    };



    const handleLeaderChanged = (data: { roomLeaderId: string; roomLeadername: string }) => {
        setRoomLeader({
            sessionId: data.roomLeaderId,
            username: data.roomLeadername,
        });
    };

    // Ïò§ÎîîÏò§ ÏÉÅÌÉú Î≥ÄÍ≤Ω Ï≤òÎ¶¨ Ìï®Ïàò
    const handleAudioStateChange = (msg) => {
        setParticipants(prev => {
            const updated = { ...prev };
            if (updated[msg.sessionId]) {
                updated[msg.sessionId].audioOn = msg.audioOn;
            }
            return updated;
        });

        if (participantsRef.current[msg.sessionId]) {
            participantsRef.current[msg.sessionId].audioOn = msg.audioOn;
        }
    };

    // ÎπÑÎîîÏò§ ÏÉÅÌÉú Î≥ÄÍ≤Ω Ï≤òÎ¶¨ Ìï®Ïàò
    const handleVideoStateChange = (msg) => {
        setParticipants(prev => {
            const updated = { ...prev };
            if (updated[msg.sessionId]) {
                updated[msg.sessionId].videoOn = msg.videoOn;
            }
            return updated;
        });

        if (participantsRef.current[msg.sessionId]) {
            participantsRef.current[msg.sessionId].videoOn = msg.videoOn;
        }
    };


    const handleUsernameChanged = (data: { sessionId: string; newUserName: string }) => {
        // participants ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        setParticipants(prev => {
            const updated = { ...prev };
            if (updated[data.sessionId]) {
            updated[data.sessionId].username = data.newUserName;
            }
            return updated;
        });

        // refÏóêÎèÑ Î∞òÏòÅ
        if (participantsRef.current[data.sessionId]) {
            participantsRef.current[data.sessionId].username = data.newUserName;
        }

        // Î≥∏Ïù∏Ïùº Í≤ΩÏö∞ userDataÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
        if (data.sessionId === userDataRef.current.sessionId) {
            setUserData(prev => ({
                ...prev,
                username: data.newUserName,
            }));
        }
    };

    const addSystemMessage = (content: string) => {
        setSystemMessages(prev => [
            ...prev,
            {
            content,
            timestamp: Date.now(),
            },
        ]);
    };

    const handleChatMessage = (
        data: {
            senderSessionId: string;
            senderName: string;
            receiverSessionId: string;
            receiverName: string;
            message: string;
        },
        isPrivate: boolean
        ) => {
        const chat: ChatMessage = {
            type: isPrivate ? 'private' : 'public',
            from: data.senderName,
            to: data.receiverName,
            content: data.message,
            sessionId: data.senderSessionId,
        };
        console.log("Chat message added:", chat); // ÎîîÎ≤ÑÍ∑∏Ïö© Î°úÍ∑∏
        setChatMessages(prev => [...prev, chat]);
    };

    const sendChatMessage = ({ to, content, isPrivate }: ChatMessageInput) => {
        // ÎÇ¥Í∞Ä Î≥¥ÎÇ∏ Î©îÏãúÏßÄÎ•º ÏÉÅÌÉúÏóê Î∞îÎ°ú Ï∂îÍ∞Ä
        const newMessage: ChatMessage = {
            type: isPrivate ? 'private' : 'public',
            from: userData.username,  // ÎÇ¥Í∞Ä Î≥¥ÎÇ∏ Î©îÏãúÏßÄÏùò Í≤ΩÏö∞, userDataÏóêÏÑú Ïù¥Î¶ÑÏùÑ Í∞ÄÏ†∏Ïò§Í∏∞Í∏∞
            to,
            content,
            sessionId: userData.sessionId,
        };

        // ÏÉÅÌÉúÏóê Ï∂îÍ∞ÄÌïòÏó¨ Ï¶âÏãú ÌëúÏãúÎêòÍ≤å ÌïòÍ∏∞
        setChatMessages((prevMessages) => [...prevMessages, newMessage]);

        const messagePayload = isPrivate
        ? {
              eventId: 'sendPersonalChat',
              receiverSessionId: to,
              message: content,
          }
        : {
              eventId: 'broadcastChat',
              message: content,
          };

        sendMessage(messagePayload);
    };

    const handleEmojiMessage = (
        data: {
            action?: string;
            senderSessionId: string;
            senderName: string;
            receiverSessionId: string;
            receiverName: string;
            emoji: string;
        }) => {
        const emojiMessage: EmojiMessage = {
            from: data.senderName,
            to: data.receiverName,
            emoji: data.emoji,
            // sessionId: data.receiverSessionId,
            sessionId: topSpeakerRef.current?.id,
        };

        console.log(topSpeakerRef.current?.id);

        setEmojiMessages((prev) => [...prev, emojiMessage]);
        
        if(data.emoji==='Raising_Hands') {
            setRaisedHandSessionIds((prev) => {
                if (!prev.includes(data.senderSessionId)) {
                    return [...prev, data.senderSessionId];
                }
                return prev;
            });
        }

        // 3Ï¥à Îí§ ÏûêÎèô Ï†úÍ±∞ (Ïï†ÎãàÎ©îÏù¥ÏÖò Ï≤òÎ¶¨ Í∞ÄÎä•)
        setTimeout(() => {
            setEmojiMessages((prev) => prev.filter((m) => m !== emojiMessage));
        }, 3000);
    };

    const finalizeRecordingSession = (/*fileName?: string*/) => {
        setRecording(false);
        setRecordingPaused(false);

        // if (fileName?.trim()) {
        //     setRecordedFiles(prev => [...prev, fileName]);
        // }
    };

    useEffect(() => {
        userDataRef.current = userData; // userDataÍ∞Ä Î∞îÎÄî ÎïåÎßàÎã§ refÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
    }, [userData]);
    
    // Ï∞∏Í∞ÄÏûê ÏÉÅÌÉúÍ∞Ä Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§ UIÏóê Î∞òÏòÅ
    useEffect(() => {
        // Ï∞∏Í∞ÄÏûêÍ∞Ä Ï∂îÍ∞ÄÎêòÏóàÏùÑ Îïå ÌôîÎ©¥Ïóê ÎπÑÎîîÏò§ ÏóÖÎç∞Ïù¥Ìä∏
        console.log('Participants updated:', participants);
        Object.values(participants).forEach((participant) => {
            if (!videoRefs.current[participant.sessionId]) {
                videoRefs.current[participant.sessionId] = React.createRef<HTMLVideoElement>();
            }
        });
    }, [participants]);

    // ÎßàÏù¥ÌÅ¨ ÏÉÅÌÉú Î≥ÄÍ≤Ω Ïãú Ïò§ÎîîÏò§ Ìä∏ÎûôÏóê Î∞òÏòÅ
    useEffect(() => {
        const stream = localStreamRef.current;
        if (stream) {
            stream.getAudioTracks().forEach(track => {
                track.enabled = micOn;
                micOnRef.current = micOn;
                setMicEnabled(micOnRef.current);
                console.log(`üé§ ÎßàÏù¥ÌÅ¨ ÏÉÅÌÉú Î≥ÄÍ≤Ω: ${micOn}`);
            });
        }
    }, [micOn]);

    // ÎπÑÎîîÏò§ ÏÉÅÌÉú Î≥ÄÍ≤Ω Ïãú ÎπÑÎîîÏò§ Ìä∏ÎûôÏóê Î∞òÏòÅ
    useEffect(() => {
        const stream = localStreamRef.current;
        if (stream) {
            stream.getVideoTracks().forEach(track => {
                track.enabled = videoOn;
                console.log(`üìπ ÎπÑÎîîÏò§ ÏÉÅÌÉú Î≥ÄÍ≤Ω: ${videoOn}`);
            });
        }
    }, [videoOn]);

    return (
    <Wrapper>
        <MainArea>
            <Header variant="compact" />
            <GalleryWrapper>
                {/* {sortedSpeakerIds.map((sessionId) => {
                    const participant = participants[sessionId];
                    if (!participant) return null;

                    return (
                    <ParticipantVideo
                        key={participant.sessionId}
                        isVideoOn={participant.videoOn}
                        isAudioOn={participant.audioOn}
                        sessionId={participant.sessionId}
                        username={participant.username}
                        ref={videoRefs.current[participant.sessionId]}
                        mySessionId={userData.sessionId}
                        emojiName={
                        emojiMessages.find((msg) => msg.sessionId === participant.sessionId)?.emoji
                        }
                        onSpeakingScoreChange={(score) =>
                            handleSpeakingScoreChange(participant.sessionId, score)
                        }
                    />
                    );
                })} */}
                <ParticipantVideoGroup $cols={sortedSpeakerIds.length-1}>
                {sortedSpeakerIds.map((sessionId, index) => {
                    const participant = participants[sessionId];
                    if (!participant) return null;

                    const isMain = index === 0;

                    return (
                    <ParticipantVideo
                        key={participant.sessionId}
                        sessionId={participant.sessionId}
                        username={participant.username}
                        isVideoOn={participant.videoOn}
                        isAudioOn={participant.audioOn}
                        ref={videoRefs.current[sessionId]}
                        mySessionId={userData.sessionId}
                        emojiName={emojiMessages.find(msg => msg.sessionId === sessionId)?.emoji}
                        onSpeakingScoreChange={(score) => handleSpeakingScoreChange(sessionId, score)}
                        className={isMain ? 'main-video' : 'sub-video'} // ‚¨ÖÔ∏è Ïä§ÌÉÄÏùº Íµ¨Î∂Ñ
                    />
                    );
                })}
                </ParticipantVideoGroup>
                {recording && (
                    <RecordingStatusPopup
                        isPaused={recordingPaused}
                        elapsed={elapsed}
                        setElapsed={setElapsed}
                        onPause={() => sendMessage({ eventId: 'pauseRecording' })}
                        onResume={() => sendMessage({ eventId: 'resumeRecording' })}
                        onStop={() => sendMessage({ eventId: 'stopRecording' })}
                    />
                )}               
            </GalleryWrapper>
            <CallControls
                micOn={micOn}
                setMicOn={handleMicToggle}
                micListVisible={micListVisible}
                setMicListVisible={handleMicListToggle}
        
                videoOn={videoOn}
                setVideoOn={handleVideoToggle}
                videoListVisible={videoListVisible}
                setVideoListVisible={handleVideoListToggle}

                screenSharing={screenSharing}
                setScreenSharing={handleScreenSharingToggle}
                recording={recording}
                recordingListVisible={recordingListVisible}
                setRecordingListVisible={handleRecordingListToggle}
                setRecording={handleRecordingToggle}
                captionsVisible={captionsVisible}
                setCaptionsVisible={handleCaptionsToggle}
                chatVisible={chatVisible}
                setChatVisible={handleChatToggle}
                participantsVisible={participantsVisible}
                setParticipantsVisible={handleParticipantsToggle}
                emotesVisible={emotesVisible}
                setEmotesVisible={handleEmotesToggle}
                onExit={exitRoom}
            />
        </MainArea>
        {changeNamePopupVisible && 
        (<NameChangePopup
            currentName={userData.username}
            onChangeName={(newName) => {
                const message = {
                eventId: 'changeName',
                sessionId: userData.sessionId,
                newUserName: newName,
                };
                sendMessage(message);
            }}
            onClose={()=>setChangeNamePopupVisible(false)}
        />)}


        {/* <ChangeNameForm
            currentName={userData.username}
            sessionId={userData.sessionId}
            onChangeName={(newName) => {
                const message = {
                eventId: 'changeName',
                sessionId: userData.sessionId,
                newUserName: newName,
                };
                sendMessage(message);
            }}
            /> */}
        <Sidebar 
            participants={Object.values(participants)} 
            participantsVisible={participantsVisible}
            chatVisible={chatVisible} 
            systemMessages={systemMessages}
            chatMessages={chatMessages}
            currentUserSessionId={userData.sessionId}
            onSendMessage={sendChatMessage}
            roomId={userData.roomId}
            raisedHandSessionIds={raisedHandSessionIds}

            changeNamePopupVisible={changeNamePopupVisible}
            setChangeNamePopupVisible={setChangeNamePopupVisible}
        />
        {emotesVisible && (
            <EmojiPicker
                participants={Object.values(participants)}
                currentUserSessionId={userData.sessionId}
                onClose={() => setEmotesVisible(false)}
                onSelect={(emojiName) => {
                    if (!topSpeaker) {
                        console.warn("‚ùó ÏàòÏã†ÏûêÍ∞Ä ÏóÜÏäµÎãàÎã§. Ïù¥Î™®ÏßÄÎ•º Î≥¥ÎÇ¥ÏßÄ ÏïäÏäµÎãàÎã§.");
                        return;
                    }

                    let messagePayload;
                    // ÏÜê ÎÇ¥Î¶¨Í∏∞ Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨
                    if (emojiName === 'Lowering_Hands') {
                        messagePayload = {
                        eventId: 'cancelHandRaise', // ÏÜê ÎÇ¥Î¶¨Í∏∞ Ïù¥Î≤§Ìä∏
                        };
                    } else{
                        // ÏÜê Îì§Í∏∞ Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨
                        messagePayload = {
                        eventId: 'sendPublicEmoji',
                        receiverSessionId: topSpeaker.id,
                        emoji: emojiName,
                        };
                    }
                    
                    sendMessage(messagePayload);
                }}
                hasSidebar={hasSidebar}
                handRaised={handRaised}
                setHandRaised={setHandRaised}
            />
        )}

        {/* ÎÖπÌôîÎ≥∏ Î¶¨Ïä§Ìä∏ ÌåùÏóÖ */}
        {/* Î∞±ÏóîÎìúÏóêÏÑú ÎÖπÌôîÎ≥∏ Î¶¨Ïä§Ìä∏Î•º Î∞õÏùÑ Í≤ΩÏö∞ */}
        {/* {recordingListVisible && (
        <ListPopup
            title="ÎÖπÌôîÎ≥∏ Îã§Ïö¥Î°úÎìú"
            items={recordedFiles}
            renderItem={(item) => (
            <span
                onClick={async () => {
                const fileName = `${item}`;
                const encodedFileName = encodeURIComponent(fileName); // üîí ÏïàÏ†ÑÌïú URL Î≥ÄÌôò
                const url = `https://vmo.o-r.kr:8080/recordings/${encodedFileName}`;

                try {
                    // HEAD ÏöîÏ≤≠ÏúºÎ°ú ÌååÏùº Ï°¥Ïû¨ ÌôïÏù∏
                    const response = await fetch(url, { method: 'HEAD' });
                    if (!response.ok) {
                    alert('ÎÖπÌôî ÌååÏùºÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.');
                    return;
                    }

                    // ÏÉàÎ°úÏö¥ Ï∞Ω Ïó¥Í∏∞
                    const downloadWindow = window.open('', '_blank');
                    if (!downloadWindow) {
                    alert('ÏÉàÎ°úÏö¥ Ï∞ΩÏùÑ Ïó¥ Ïàò ÏóÜÏäµÎãàÎã§.');
                    return;
                    }

                    // Îã§Ïö¥Î°úÎìú ÎßÅÌÅ¨ ÏÉùÏÑ± Î∞è ÌÅ¥Î¶≠
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    downloadWindow.document.body.appendChild(a);
                    a.click();

                    // Ï∞ΩÏù¥ Îã´ÌûàÎèÑÎ°ù ÏÑ§Ï†ï
                    downloadWindow.close();
                    closeRecordingList();
                } catch (error) {
                    console.error('Îã§Ïö¥Î°úÎìú Ï§ë Ïò§Î•ò Î∞úÏÉù:', error);
                    alert('Îã§Ïö¥Î°úÎìúÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
                }
                }}
                title="ÌÅ¥Î¶≠Ìï¥ÏÑú Îã§Ïö¥Î°úÎìú"
            >
                {item}
            </span>
            )}
            onClose={closeRecordingList}
            hasSidebar={hasSidebar}
            popupLeft={45}
        />
        )} */}

        {recordingListVisible && (
        <ListPopup
            title="ÎÖπÌôîÎ≥∏ Îã§Ïö¥Î°úÎìú"
            items={recordedFiles}
            renderItem={(item) => (
            <span
                onClick={() => {
                const a = document.createElement('a');
                a.href = item.url;               // urlÎ°ú Ï†ëÍ∑º
                a.download = item.fileName;     // ÌååÏùº Ïù¥Î¶ÑÏúºÎ°ú Îã§Ïö¥Î°úÎìú
                a.click();
                closeRecordingList();
                }}
                title="ÌÅ¥Î¶≠Ìï¥ÏÑú Îã§Ïö¥Î°úÎìú"
                style={{ cursor: 'pointer' }}
            >
                {item.fileName}  {/* ÏÇ¨Ïö©ÏûêÏóêÍ≤å Î≥¥Ïó¨Ï§Ñ ÌååÏùºÎ™Ö */}
            </span>
            )}
            onClose={closeRecordingList}
            hasSidebar={hasSidebar}
            popupLeft={45}
        />
        )}

        {recordingPopupVisible && (
            <RecordingPermissionPopup 
                username={participants[pendingSessionId]?.username || 'Ïïå Ïàò ÏóÜÎäî ÏÇ¨Ïö©Ïûê'} 

                onGrant={() => {
                    sendMessage({
                        eventId: 'grantRecordingPermission',
                        sessionId: pendingSessionId
                    });
                    setRecordingPopupVisible(false);
                    setPendingSessionId(null);
                }}

                onDeny={() => {
                    sendMessage({
                        eventId: 'denyRecordingPermission',
                        sessionId: pendingSessionId
                    });
                    setRecordingPopupVisible(false);
                    setPendingSessionId(null);
                }}
        />)}
        {recordingConsentPopupVisible && (
            <RecordingConsentPopup
                onConfirmConsent={()=>{
                    setRecordingConsentPopupVisible(false);
                }}

                onDeclineConsent={()=>{
                    setRecordingConsentPopupVisible(false);
                    exitRoom();
                }}
            />
        )}
        {micListVisible&&(<AudioInputSelector onDeviceChange={replaceAudioTrack} />)}
        {videoListVisible&&(<VideoInputSelector onDeviceChange={replaceVideoTrack} />)}
    </Wrapper>
    );
};

export default Conference;
